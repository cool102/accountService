type: edu
custom_name: Security first!
files:
  - name: build.gradle
    visible: true
    text: |-
      plugins {
          id 'java'
          id 'org.springframework.boot' version '2.3.1.RELEASE'
          id 'io.spring.dependency-management' version '1.0.9.RELEASE'
      }
      
      repositories {
          mavenCentral()
      }
      
      sourceSets.main.resources.srcDirs = ["src/resources"]
      
      dependencies {
          implementation 'org.springframework.boot:spring-boot-starter'
          implementation 'org.springframework.boot:spring-boot-starter-actuator'
          implementation 'org.springframework.boot:spring-boot-starter-web'
          implementation group: 'org.hibernate', name: 'hibernate-validator', version: '6.1.0.Final'
      }
    learner_created: false
  - name: src/account/AccountServiceApplication.java
    visible: true
    text: |-
      package account;
      
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      
      @SpringBootApplication
      public class AccountServiceApplication {
      
          public static void main(String[] args) {
              SpringApplication.run(AccountServiceApplication.class, args);
          }
      
      }
    learner_created: false
  - name: src/resources/application.properties
    visible: true
    text: |-
      server.port=28852
      management.endpoints.web.exposure.include=*
      management.endpoint.shutdown.enabled=true
      spring.jackson.serialization.INDENT_OUTPUT=true
    learner_created: false
  - name: test/AccountServiceTest.java
    visible: false
    text: |-
      import account.AccountServiceApplication;
      import com.fasterxml.jackson.annotation.JsonInclude;
      import com.fasterxml.jackson.core.JsonProcessingException;
      import com.fasterxml.jackson.databind.ObjectMapper;
      import com.google.gson.JsonObject;
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.dynamic.input.DynamicTesting;
      import org.hyperskill.hstest.exception.outcomes.UnexpectedError;
      import org.hyperskill.hstest.mocks.web.response.HttpResponse;
      import org.hyperskill.hstest.stage.SpringTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      
      import java.util.ArrayList;
      import java.util.LinkedHashMap;
      import java.util.List;
      import java.util.Map;
      import java.util.stream.Collectors;
      
      import static org.hyperskill.hstest.common.JsonUtils.getJson;
      import static org.hyperskill.hstest.common.JsonUtils.getPrettyJson;
      import static org.hyperskill.hstest.testing.expect.Expectation.expect;
      import static org.hyperskill.hstest.testing.expect.json.JsonChecker.*;
      
      class TestReq {
      
        private Map<String, String> properties = new LinkedHashMap<>();
      
        // Deep copy
        public TestReq(TestReq another) {
          this.properties = another.properties.entrySet().stream()
                  .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        }
      
        public TestReq() {
        }
      
        public String toJson() {
          ObjectMapper mapper = new ObjectMapper();
          mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
          try {
            return mapper.writeValueAsString(this.properties);
          } catch (JsonProcessingException e) {
            System.out.println(e.getMessage());
            return null;
          }
        }
      
        public TestReq setProps(String key, String value) {
          properties.put(key, value);
          return this;
        }
      
      }
      
      public class AccountServiceTest extends SpringTest {
      
        private  final String signUpApi = "/api/auth/signup";
        private  final String changePassApi = "/api/auth/changepass";
        private  final String paymentApi = "/api/empl/payment";
        private final TestReq johnDoe = new TestReq().setProps("name", "John")
                .setProps("lastname", "Doe")
                .setProps("email", "JohnDoe@acme.com")
                .setProps("password", "oMoa3VvqnLxW");
        private final TestReq maxMus = new TestReq().setProps("name", "Max")
                .setProps("lastname", "Mustermann")
                .setProps("email", "MaxMustermann@acme.com")
                .setProps("password", "ai0y9bMvyF6G");
        private final TestReq captainNemo = new TestReq().setProps("name", "Captain")
                .setProps("lastname", "Nemo")
                .setProps("email", "nautilus@pompilius.com")
                .setProps("password", "wings");
      
        private final String jDCorrectUser = johnDoe.toJson();
        private final String jDEmptyName = new TestReq(johnDoe).setProps("name", "").toJson();
        private final String jDNoName = new TestReq(johnDoe).setProps("name", null).toJson();
        private final String jDEmptyLastName = new TestReq(johnDoe).setProps("lastname", "").toJson();
        private final String jDNoLastName = new TestReq(johnDoe).setProps("lastname", null).toJson();
        private final String jDEmptyEmail = new TestReq(johnDoe).setProps("email", "").toJson();
        private final String jDNoEmail = new TestReq(johnDoe).setProps("email", null).toJson();
        private final String jDEmptyPassword = new TestReq(johnDoe).setProps("password", "").toJson();
        private final String jDNoPassword = new TestReq(johnDoe).setProps("password", null).toJson();
        private final String jDWrongEmail1 = new TestReq(johnDoe).setProps("email", "johndoeacme.com").toJson();
        private final String jDWrongEmail2 = new TestReq(johnDoe).setProps("email", "johndoe@google.com").toJson();
        private final String maxMusCorrectUser = maxMus.toJson();
        private final String jDLower = new TestReq(johnDoe).setProps("email", "johndoe@acme.com").toJson();
        private final String maxMusLower = new TestReq(maxMus).setProps("email", "maxmustermann@acme.com").toJson();
        private final String jDWrongPassword = new TestReq(johnDoe).setProps("password", "none").toJson();
        private final String maxMusWrongPassword = new TestReq(maxMus).setProps("password", "none").toJson();
        private final String captainNemoWrongUser = captainNemo.toJson();
      
        private final String jDDuplicatePass = new TestReq().setProps("new_password", "oMoa3VvqnLxW").toJson();
      
        private final String jDShortPass1 = new TestReq().setProps("new_password", "o").toJson();
        private final String jDShortPass2 = new TestReq().setProps("new_password", "oM").toJson();
        private final String jDShortPass3 = new TestReq().setProps("new_password", "oMo").toJson();
        private final String jDShortPass4 = new TestReq().setProps("new_password", "oMoa").toJson();
        private final String jDShortPass5 = new TestReq().setProps("new_password", "oMoa3").toJson();
        private final String jDShortPass6 = new TestReq().setProps("new_password", "oMoa3V").toJson();
        private final String jDShortPass7 = new TestReq().setProps("new_password", "oMoa3Vv").toJson();
        private final String jDShortPass8 = new TestReq().setProps("new_password", "oMoa3Vvq").toJson();
        private final String jDShortPass9 = new TestReq().setProps("new_password", "oMoa3Vvqn").toJson();
        private final String jDShortPass10 = new TestReq().setProps("new_password", "oMoa3Vvqno").toJson();
        private final String jDShortPass11 = new TestReq().setProps("new_password", "oMoa3VvqnoM").toJson();
      
      
        private final String jDPass = new TestReq().setProps("new_password", "aNob5VvqzRtb").toJson();
      
      
        static String[] breachedPass= new String[]{"PasswordForJanuary", "PasswordForFebruary", "PasswordForMarch",
                "PasswordForApril", "PasswordForMay", "PasswordForJune",
                "PasswordForJuly", "PasswordForAugust", "PasswordForSeptember",
                "PasswordForOctober", "PasswordForNovember", "PasswordForDecember"};
      
        List<Integer> userIdList = new ArrayList<>();
      
        public AccountServiceTest() {
          super(AccountServiceApplication.class, "../service_db.mv.db");
        }
      
        /**
         * Method for checking status code of response Post request for API
         *
         * @param api testing api (String)
         * @param body string representation of body content in JSON format (String)
         * @param status required http status for response (int)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        CheckResult testPostApi(String api, String body, int status, String message) {
          HttpResponse response = post(api, body).send();
          if (response.getStatusCode() != status) {
            return CheckResult.wrong("POST " + api + " should respond with "
                    + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                    + message + "\n"
                    + "Response body:\n" + response.getContent() + "\n"
                    + "Request body:\n" + body);
          }
          return CheckResult.correct();
        }
      
        CheckResult testPostApiWithAuth(String api, String body, int status, String login, String pass, String message) {
          HttpResponse response = post(api, body).basicAuth(login, pass).send();
      
          if (response.getStatusCode() == 404) {
            return CheckResult.wrong("POST " + api + " should respond with "
                    + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                    + "Endpoint not found!" + "\n"
                    + "Response body:\n" + response.getContent() + "\n"
                    + "Request body:\n" + body);
          }
      
          if (response.getStatusCode() != status) {
            return CheckResult.wrong("POST " + api + " should respond with "
                    + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                    + message + "\n"
                    + "Response body:\n" + response.getContent() + "\n"
                    + "Request body:\n" + body);
          }
          return CheckResult.correct();
        }
      
        /**
         * Method for checking status code of response Get request for API
         *
         * @param api testing api (String)
         * @param status required http status for response (int)
         * @param message hint about reason of error (String)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        CheckResult testGetApi(String api, int status, String message) {
          HttpResponse response = get(api).send();
      
          if (response.getStatusCode() != status) {
            return CheckResult.wrong("GET " + api + " should respond with "
                    + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                    + message);
          }
          return CheckResult.correct();
        }
      
        /**
         * Method for checking status code of response Get request for API
         *
         * @param api testing api (String)
         * @param status required http status for response (int)
         * @param message hint about reason of error (String)
         * @param login login
         * @param password password
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        CheckResult testGetApiAuth(String api, int status, String login, String password, String message) {
          HttpResponse response = get(api).basicAuth(login, password).send();
      
          if (response.getStatusCode() != status) {
            return CheckResult.wrong("GET " + api + " should respond with "
                    + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                    + message);
          }
          return CheckResult.correct();
        }
      
        /**
         * Method for checking response on Post request for signup API
         *
         * @param body string representation of body content in JSON format (String)
         * @param status required http status for response (int)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        CheckResult testPostSignUpResponse(String body, int status) {
          HttpResponse response = post(signUpApi, body).send();
          testPostApi(signUpApi, body, status, "API must be available");
      
          JsonObject rightResponse = getJson(body).getAsJsonObject();
          rightResponse.remove("password");
      
          // Check is it JSON in response or something else
          if (!response.getJson().isJsonObject()) {
            return CheckResult.wrong("Wrong object in response, expected JSON but was \n" +
                    response.getContent().getClass());
      
          }
      
          JsonObject jsonResponse = response.getJson().getAsJsonObject();
      
          // Check if password is presence in response
          if (jsonResponse.get("password") != null) {
            return CheckResult.wrong("You must remove password from response\n" +
                    jsonResponse);
          }
      
          if (jsonResponse.get("id") == null) {
            return CheckResult.wrong("Response must contain user ID\n" +
                    "Received response:\n" +
                    jsonResponse);
          }
      
      
      
          // Check JSON in response
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("id", isInteger())
                          .value("name", rightResponse.get("name").getAsString())
                          .value("lastname", rightResponse.get("lastname").getAsString())
                          .value("email", isString(s -> s.equalsIgnoreCase(rightResponse.get("email").getAsString()))));
      
          if (userIdList.contains(jsonResponse.get("id").getAsInt())) {
            return CheckResult.wrong("User ID must be unique!\n" +
                    "Received response:\n" +
                    jsonResponse);
          }
      
          userIdList.add(jsonResponse.get("id").getAsInt());
          return CheckResult.correct();
        }
      
        /**
         * Method for restarting application
         *
         */
        private CheckResult restartApplication() {
          try {
            reloadSpring();
          } catch (Exception ex) {
            throw new UnexpectedError(ex.getMessage());
          }
          return CheckResult.correct();
        }
      
        /**
         * Method for checking authentication
         *
         * @param user string representation of user information in JSON format (String)
         * @param status required http status for response (int)
         * @param message hint about reason of error (String)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        private CheckResult testUserRegistration(String user, int status, String message) {
          JsonObject userJson = getJson(user).getAsJsonObject();
          String password = userJson.get("password").getAsString();
          String login = userJson.get("email").getAsString().toLowerCase();
          HttpResponse response = get(paymentApi).basicAuth(login, password).send();
          if (response.getStatusCode() != status) {
            return CheckResult.wrong("Get " + paymentApi + " should respond with "
                    + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                    + message + "\n"
                    + "Authentication with " + login + " / " + password);
          }
          // Check JSON in response
          if (status == 200) {
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("id", isInteger())
                            .value("name", userJson.get("name").getAsString())
                            .value("lastname", userJson.get("lastname").getAsString())
                            .value("email", isString(s -> s.equalsIgnoreCase(userJson.get("email").getAsString()))));
          }
          return CheckResult.correct();
        }
      
        CheckResult testChangePassword(String api, String body, int status, String user, String answer) {
          JsonObject userJson = getJson(user).getAsJsonObject();
          String pass = userJson.get("password").getAsString();
          String login = userJson.get("email").getAsString().toLowerCase();
          HttpResponse response = post(api, body).basicAuth(login, pass).send();
          if (response.getStatusCode() != status) {
            return CheckResult.wrong("POST " + api + " should respond with "
                    + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                    + "Response body:\n" + response.getContent() + "\n"
                    + "Request body:\n" + body);
          }
          // Check JSON in response
          if (status == 200) {
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("email", userJson.get("email").getAsString().toLowerCase())
                            .value("status", answer));
          }
          if (status == 400) {
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("status", 400)
                            .value("error", "Bad Request")
                            .value("message", answer)
                            .value("path", "/api/auth/changepass")
                            .anyOtherValues());
          }
          return CheckResult.correct();
        }
      
        /**
         * Method for testing duplicate users
         *
         * @param user string representation of user information in JSON format (String)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        private CheckResult testUserDuplicates(String user) {
          HttpResponse response = post(signUpApi, user).send();
          // Check error message field in JSON response
          expect(response.getContent()).asJson().check(
                  isObject()
                          .value("status", 400)
                          .value("error", "Bad Request")
                          .value("message", "User exist!")
                          .anyOtherValues());
          return CheckResult.correct();
        }
      
        private CheckResult testBreachedPass(String api, String login, String password, String body, String message) {
          JsonObject json = getJson(body).getAsJsonObject();
          HttpResponse response;
          for (int index = 0; index < breachedPass.length; index++) {
            if (json.has("password")) {
              json.remove("password");
              json.addProperty("password", breachedPass[index]);
            } else if (json.has("new_password")) {
              json.remove("new_password");
              json.addProperty("new_password", breachedPass[index]);
            }
            if (login.isEmpty() || password.isEmpty()) {
              response = post(api, json.toString()).send();
            } else {
              response = post(api, json.toString()).basicAuth(login, password).send();
            }
      
            if (response.getStatusCode() != 400) {
              return CheckResult.wrong("POST " + api + " should respond with "
                      + "status code 400 , responded: " + response.getStatusCode() + "\n"
                      + "Response body:\n" + response.getContent() + "\n"
                      + "Request body:\n" + getPrettyJson(json) + "\n"
                      + message);
            }
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("status", 400)
                            .value("error", "Bad Request")
                            .value("message", "The password is in the hacker's database!")
                            .anyOtherValues());
      
          }
          return CheckResult.correct();
        }
      
        @DynamicTest
        DynamicTesting[] dt = new DynamicTesting[] {
      
                // Test wrong POST request for signup api
                () -> testPostApi(signUpApi, jDEmptyName, 400, "Empty name field!"),
                () -> testPostApi(signUpApi, jDNoName, 400, "Name field is absent!"),
                () -> testPostApi(signUpApi, jDEmptyLastName, 400, "Empty lastname field!"),
                () -> testPostApi(signUpApi, jDNoLastName, 400, "Lastname field is absent!"),
                () -> testPostApi(signUpApi, jDEmptyEmail, 400, "Empty email field!"),
                () -> testPostApi(signUpApi, jDNoEmail, 400, "Email field is absent!"),
                () -> testPostApi(signUpApi, jDEmptyPassword, 400, "Empty password field!"),
                () -> testPostApi(signUpApi, jDNoPassword, 400, "Password field is absent!"),
                () -> testPostApi(signUpApi, jDWrongEmail1, 400, "Wrong email!"),
                () -> testPostApi(signUpApi, jDWrongEmail2, 400, "Wrong email!"),
                // Test user registration on signup api
                // Test user registration on signup api
                () -> testBreachedPass(signUpApi, "", "",
                        jDCorrectUser, "Sending password from breached list"),
                () -> testPostSignUpResponse(jDCorrectUser, 200),
                () -> testPostApi(signUpApi, jDCorrectUser, 400, "User must be unique!"),
                () -> testUserDuplicates(jDCorrectUser),
                () -> testPostApi(signUpApi, jDLower, 400, "User must be unique (ignorecase)!"),
                () -> testPostSignUpResponse(maxMusLower, 200),
                () -> testPostApi(signUpApi, maxMusLower, 400, "User must be unique!"),
                () -> testPostApi(signUpApi, maxMusCorrectUser, 400, "User must be unique (ignorecase)!"),
                // Test authentication, positive tests
                () -> testUserRegistration(jDLower, 200, "User must login!"),
                () -> testUserRegistration(jDCorrectUser, 200, "Login case insensitive!"),
                () -> testUserRegistration(maxMusLower, 200, "User must login!"),
                () -> testUserRegistration(maxMusCorrectUser, 200, "Login case insensitive!"),
                // Test authentication, negative tests
                () -> testUserRegistration(jDWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(jDWrongEmail1, 401, "Wrong user!"),
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"),
                () -> testUserRegistration(captainNemoWrongUser, 401, "Wrong user"),
                () -> testGetApi(paymentApi, 401, "This api only for authenticated user"),
                // Test changing password
                () -> testPostApi(changePassApi, jDDuplicatePass, 401, "This api only for authenticated user"),
                () -> testChangePassword(changePassApi, jDShortPass1, 400, jDCorrectUser,
                        "Password length must be 12 chars minimum!"),
                () -> testChangePassword(changePassApi, jDDuplicatePass, 400, jDCorrectUser,
                        "The passwords must be different!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass1, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass2, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass3, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass4, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass5, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass6, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass7, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass8, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass9, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass10, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDShortPass11, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"),
                () -> testPostApiWithAuth(changePassApi, jDDuplicatePass, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The passwords must be different!"),
                () -> testBreachedPass(changePassApi, "JohnDoe@acme.com", "oMoa3VvqnLxW",
                        jDDuplicatePass, "Sending password from breached list"),
                // Test persistence
                () -> restartApplication(),
                () -> testUserRegistration(maxMusCorrectUser, 200, "User must login, after restarting!" +
                        " Check persistence."),
                () -> testChangePassword(changePassApi, jDPass, 200, jDCorrectUser, "The password has been updated successfully"),
                () -> testGetApiAuth(paymentApi, 401,"JohnDoe@acme.com",
                        "oMoa3VvqnLxW", "Password must be changed!"),
                () -> testGetApiAuth(paymentApi, 200,"JohnDoe@acme.com",
                        "aNob5VvqzRtb", "Password must be changed!"),
                () -> testChangePassword(changePassApi, jDPass, 200, maxMusCorrectUser, "The password has been updated successfully"),
                () -> testGetApiAuth(paymentApi, 401,"MaxMustermann@acme.com",
                        "ai0y9bMvyF6G", "Password must be changed!"),
                () -> testGetApiAuth(paymentApi, 200,"MaxMustermann@acme.com",
                        "aNob5VvqzRtb", "Password must be changed!")
        };
      }
    learner_created: false
  - name: src/account/errors/UserExistException.java
    visible: true
    text: |
      package account.errors;
      
      public class UserExistException extends RuntimeException{
          public UserExistException() {
              super("User exist!");
          }
      }
    learner_created: true
  - name: src/account/errors/WrongFormatUserInfoJson.java
    visible: true
    text: |
      package account.errors;
      
      public class WrongFormatUserInfoJson extends RuntimeException{
          public WrongFormatUserInfoJson() {
              super();
          }
      }
    learner_created: true
  - name: src/account/UserInfoDetailsImpl.java
    visible: true
    text: |
      package account;
      
      import account.businesslayer.UserInfo;
      import org.springframework.security.core.GrantedAuthority;
      import org.springframework.security.core.userdetails.UserDetails;
      
      import java.util.Collection;
      
      public class UserInfoDetailsImpl implements UserDetails {
          private final String name;
          private final String lastname;
          private final String email;
          private final String password;
      
          public UserInfoDetailsImpl(UserInfo userInfo) {
              this.name = userInfo.getName();
              this.lastname = userInfo.getLastname();
              this.email = userInfo.getEmail();
              this.password = userInfo.getPassword();
          }
      
          public String getEmail() {
              return email;
          }
      
          @Override
          public Collection<? extends GrantedAuthority> getAuthorities() {
              return null;
          }
      
          @Override
          public String getPassword() {
              return password;
          }
      
          @Override
          public String getUsername() {
              return name;
          }
      
          @Override
          public boolean isAccountNonExpired() {
              return true;
          }
      
          @Override
          public boolean isAccountNonLocked() {
              return true;
          }
      
          @Override
          public boolean isCredentialsNonExpired() {
              return true;
          }
      
          @Override
          public boolean isEnabled() {
              return true;
          }
      }
    learner_created: true
  - name: src/account/businesslayer/UserInfo.java
    visible: true
    text: |
      package account.businesslayer;
      
      import com.fasterxml.jackson.annotation.JsonProperty;
      
      import javax.persistence.*;
      import javax.validation.constraints.NotEmpty;
      import javax.validation.constraints.NotNull;
      import javax.validation.constraints.Pattern;
      
      @Entity
      @Table(name = "user")
      public class UserInfo {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          @Column
          private long id;
          @Column
          @NotEmpty
          private String name;
          @Column
          @NotEmpty
          private String lastname;
          @Column
          @NotNull
          @Pattern(regexp = "[a-zA-Z]+@acme.com")
          private String email;
          @Column
          @NotEmpty
          @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
      // – аннотация работает только тогда когда мы получаем объект из JSON
          private String password;
      
          public UserInfo(String name, String lastname, String email, String password) {
              this.name = name;
              this.lastname = lastname;
              this.email = email;
              this.password = password;
          }
      
          public long getId() {
              return id;
          }
      
          public UserInfo() {
          }
      
          public UserInfo(long id, String name, String lastname, String email) {
              this.id = id;
              this.name = name;
              this.lastname = lastname;
              this.email = email;
          }
      
          public String getName() {
              return name;
          }
      
          public void setName(String name) {
              this.name = name;
          }
      
          public String getLastname() {
              return lastname;
          }
      
          public void setLastname(String lastname) {
              this.lastname = lastname;
          }
      
          public String getEmail() {
              return email;
          }
      
          public void setEmail(String email) {
              this.email = email;
          }
      
          public String getPassword() {
              return password;
          }
      
          public void setId(long id) {
              this.id = id;
          }
      
          public void setPassword(String password) {
              this.password = password;
          }
      }
    learner_created: true
  - name: src/account/Security.java
    visible: true
    text: |
      package account;
      
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.context.annotation.Bean;
      import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
      import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
      import org.springframework.security.config.http.SessionCreationPolicy;
      import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
      import org.springframework.security.crypto.password.PasswordEncoder;
      
      @EnableWebSecurity
      public class Security extends WebSecurityConfigurerAdapter {
          @Autowired
          UserInfoDetailsService userInfoDetailsService;
      
      
          @Override
          protected void configure(AuthenticationManagerBuilder auth) throws Exception {
              auth
                      .userDetailsService(userInfoDetailsService)
                      .passwordEncoder(getEncoder());
      
      
          }
      
          @Override
          protected void configure(HttpSecurity http) throws Exception {
              http
                      .authorizeRequests()
                      .mvcMatchers("/api/auth/signup").permitAll()
                      .mvcMatchers("/api/empl/payment").authenticated()
                      .and()
                      .sessionManagement()
                      .sessionCreationPolicy(SessionCreationPolicy.STATELESS) // no session
                      .and()
                      .csrf().disable().headers().frameOptions().disable()
                      .and()
                      .httpBasic(); // (3)
          }
      
          @Bean
          public PasswordEncoder getEncoder() {
              return new BCryptPasswordEncoder();
          }
      
      
      }
    learner_created: true
  - name: src/resources/static/index.html
    visible: true
    text: |-
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <title>Main</title>
      </head>
      <body>
      <h1>Welcome!</h1>
      </body>
      </html>
    learner_created: true
  - name: src/account/errors/ControllerExceptionHandler.java
    visible: true
    text: |
      package account.errors;
      
      import org.springframework.http.HttpHeaders;
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.MethodArgumentNotValidException;
      import org.springframework.web.bind.annotation.ControllerAdvice;
      import org.springframework.web.bind.annotation.ExceptionHandler;
      import org.springframework.web.context.request.WebRequest;
      import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
      
      import java.time.LocalDateTime;
      import java.util.LinkedHashMap;
      import java.util.Map;
      
      @ControllerAdvice
      public class ControllerExceptionHandler extends ResponseEntityExceptionHandler {
      
          @ExceptionHandler(UserExistException.class)
          public ResponseEntity<Object> handleUserExistException(
                  UserExistException e, WebRequest request) {
      
              Map<String, Object> body = new LinkedHashMap<>();
              body.put("timestamp", LocalDateTime.now());
              body.put("status", HttpStatus.BAD_REQUEST.value());
              body.put("error", HttpStatus.BAD_REQUEST.getReasonPhrase());
              body.put("message", e.getMessage());
              body.put("path", request.getDescription(false).replace("uri=", ""));
      
      
              return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
          }
      
          @Override
          protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {
      
              Map<String, Object> body = new LinkedHashMap<>();
              body.put("timestamp", LocalDateTime.now());
              body.put("status", HttpStatus.BAD_REQUEST.value());
              body.put("error", HttpStatus.BAD_REQUEST.getReasonPhrase());
              body.put("path", request.getDescription(false).replace("uri=", ""));
              return new ResponseEntity<>(body, headers, status);
          }
      }
    learner_created: true
  - name: src/account/UserInfoDetailsService.java
    visible: true
    text: |
      package account;
      
      import account.businesslayer.UserInfo;
      import account.businesslayer.UserInfoService;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.security.core.userdetails.UserDetails;
      import org.springframework.security.core.userdetails.UserDetailsService;
      import org.springframework.security.core.userdetails.UsernameNotFoundException;
      import org.springframework.stereotype.Service;
      
      @Service
      public class UserInfoDetailsService implements UserDetailsService {
          @Autowired
          UserInfoService service;
      
          @Override
          public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
              UserInfo userinfo = service.findUserByEmail(email.toLowerCase());
              if (userinfo == null) {
                  throw new UsernameNotFoundException("Not found: " + email);
              }
              return new UserInfoDetailsImpl(userinfo);
          }
      }
    learner_created: true
  - name: src/account/presentation/Controller.java
    visible: true
    text: |
      package account.presentation;
      
      import account.businesslayer.UserInfoService;
      import account.errors.UserExistException;
      import account.UserInfoDetailsImpl;
      import account.businesslayer.UserInfo;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.security.core.Authentication;
      import org.springframework.security.crypto.password.PasswordEncoder;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.PostMapping;
      import org.springframework.web.bind.annotation.RequestBody;
      import org.springframework.web.bind.annotation.RestController;
      
      import javax.validation.Valid;
      import java.util.List;
      
      @RestController
      public class Controller {
      
          @Autowired
          UserInfoService service;
      
          @Autowired
          PasswordEncoder encoder;
      
      
          @GetMapping(value = "/api/empl/payment")
          public UserInfo getPayment(Authentication auth) {
              UserInfoDetailsImpl details = (UserInfoDetailsImpl) auth.getPrincipal();
      
              UserInfo userByEmail = service.findUserByEmail(details.getEmail());
              return new UserInfo(userByEmail.getId(),
                      userByEmail.getName(),
                      userByEmail.getLastname(),
                      userByEmail.getEmail());
      
      
          }
      
      
          @PostMapping(value = "/api/auth/signup")
          public UserInfo signup(@Valid @RequestBody UserInfo user) {
      
              if (isEmailExist(service, user.getEmail().toLowerCase())) {
                  throw new UserExistException();
              } else {
                  user.setPassword(encoder.encode((user.getPassword())));
                  UserInfo userToSave = new UserInfo(
                          user.getName(),
                          user.getLastname(),
                          user.getEmail().toLowerCase(),
                          user.getPassword()
                  );
                  UserInfo savedUser = service.save(userToSave);
                  return new UserInfo(savedUser.getId(), savedUser.getName(), savedUser.getLastname(), savedUser.getEmail().toLowerCase());
              }
      
          }
      
      
          private static boolean isEmailExist(UserInfoService service, String email) {
      
              List<UserInfo> allUsers = service.findAllUsers();
              if (allUsers.isEmpty()) {
                  return false;
              } else {
                  for (var user : allUsers
                  ) {
                      if (user.getEmail().equalsIgnoreCase(email))
                          return true;
                  }
                  return false;
              }
      
          }
      
      
      }
    learner_created: true
  - name: src/account/errors/CompromisedPasswordException.java
    visible: true
    learner_created: true
  - name: src/account/businesslayer/Password.java
    visible: true
    learner_created: true
  - name: src/account/errors/SamePasswordException.java
    visible: true
    learner_created: true
  - name: src/account/businesslayer/Salary.java
    visible: true
    learner_created: true
  - name: src/account/businesslayer/PayRoll.java
    visible: true
    learner_created: true
  - name: src/account/persistence/AccountRepository.java
    visible: true
    learner_created: true
  - name: src/account/businesslayer/UserInfoService.java
    visible: true
    text: |
      package account.businesslayer;
      
      import account.businesslayer.UserInfo;
      import account.persistence.Repository;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.stereotype.Service;
      
      import java.util.List;
      
      @Service
      public class UserInfoService {
          private final Repository repository;
      
          @Autowired
          public UserInfoService(Repository repository) {
              this.repository = repository;
          }
      
          public UserInfo save(UserInfo toSave) {
              return repository.save(toSave);
          }
      
      
          public List<UserInfo> findAllUsers() {
              return (List<UserInfo>) repository.findAll();
          }
      
          public UserInfo findUserByEmail(String email) {
              for (UserInfo user : repository.findAll()
              ) {
                  if (user.getEmail().equals(email)) {
                      return user;
                  }
              }
              return null;
          }
      
          public UserInfo findUserByName(String name) {
              for (UserInfo user : repository.findAll()
              ) {
                  if (user.getName().equals(name)) {
                      return user;
                  }
              }
              return null;
          }
      
      
      }
    learner_created: true
feedback_link: https://hyperskill.org/projects/217/stages/1088/implement#comment
status: Solved
feedback:
  message: Congratulations!
  time: Tue, 26 Jul 2022 13:52:47 UTC
record: 3
